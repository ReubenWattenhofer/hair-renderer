Shader "Custom/Transparency/Background_hair_combiner" {
	// from "Hair Self Shadowing and Transparency Depth Ordering Using Occupancy maps"
	SubShader{
	Tags {"Queue" = "Transparent" "RenderType" = "Transparent" }


	LOD 100
		ZWRITE On
		//ZWRITE Off
		Cull Off


		// https://docs.unity3d.com/Manual/SL-GrabPass.html
		// Grab the screen behind the object into _BackgroundTexture
		GrabPass
		{
			"_BackgroundTexture"
		}

		Pass{
		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag
		#include "UnityCG.cginc"

		#include "../HairCommon.cginc"

		sampler2D _BackgroundTexture;
	
		// generated by TransparencySorting
		float _AlphaMultiplier;
		//sampler2D _MainDepth;
		sampler2D _Hair;
		sampler2D _MainSlab;


		struct v2f {
			float4 pos : SV_POSITION;
			float4 scrPos : TEXCOORD1;
			float3 viewPos : TEXCOORD2;

			float4 grabPos : TEXCOORD0;
		};

		//Vertex Shader
		v2f vert(appdata_base v) {
			v2f o;
			o.pos = UnityObjectToClipPos(v.vertex);
			o.scrPos = ComputeScreenPos(o.pos);
			o.viewPos = UnityObjectToViewPos(v.vertex);

			// use ComputeGrabScreenPos function from UnityCG.cginc
			// to get the correct texture coordinate
			o.grabPos = ComputeGrabScreenPos(o.pos);

			return o;
		}

		//Fragment Shader
		float4 frag(v2f i) : COLOR {
			i.scrPos /= i.scrPos.w;

			float4 slabs = tex2D(_MainSlab, i.scrPos) * 1;

			float4 background = tex2Dproj(_BackgroundTexture, i.grabPos);

			float4 hair = tex2D(_Hair, i.scrPos);

			// How many fragments are in this texel?
			float allFragments = slabs.r + slabs.g + slabs.b + slabs.a;

			//allFragments = max(0, allFragments);

			float4 col = float4(0, 0, 0, 0);
			
			// Sampling a texel with no hair?
			if (hair.r == 0) 
			{
				col = background;
			}
			else
			{
				// I left these in for debugging

				//col = slabs;
				//col = tex2D(_MainDepth, i.scrPos);
				//col.g = tex2D(_MainDepth, i.scrPos).a;
				col = hair + (background * pow(1 - _AlphaMultiplier, allFragments));
				//col = hair + background;
			}
					   
			return col;

		}
		ENDCG
		}
	}
		// NO fallback, because that would cast shadows - bad!
		//FallBack "Diffuse"
}