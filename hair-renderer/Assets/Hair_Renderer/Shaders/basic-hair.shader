// Upgrade NOTE: replaced '_Object2World' with 'unity_ObjectToWorld'

// Upgrade NOTE: replaced '_LightMatrix0' with 'unity_WorldToLight'

Shader "Custom/basic"
{
	Properties
	{
		_MainTex("Albedo Texture", 2D) = "white" {}
		_AlphaTex("Alpha Texture", 2D) = "white" {}
		_AmbientOcclusion("Ambient Occlusion", 2D) = "white" {}
		_Brightness("Brightness", 2D) = "white" {}

		_SpecularShift("Specular Shift", 2D) = "gray" {}

		_CutoutThresh("Alpha Cutoff", Range(0.0,1.0)) = 0.5
		_AlphaMultiplier("Alpha Multiplier", Range(0.0,1.0)) = 0.8
		_TintColor("Tint Color", Color) = (1,1,1,1)
		_Highlight1("Primary Highlight", Color) = (1,1,1,1)
		_Highlight2("Secondary Highlight", Color) = (1,1,1,1)
		_SecondarySparkle("Secondary Highlight Sparkle", 2D) = "white" {}

		// These values are from the Blacksmith hair shader (Unity Asset Store)
		_PrimaryShift("Primary Shift", Range(-5.0, 5.0)) = 0.275
		_SecondaryShift("Secondary Shift", Range(-5.0, 5.0)) = -0.040
		_SpecExp1("Specularity Exponent 1", Float) = 64
		_SpecExp2("Specularity Exponent 2", Float) = 48

		_Ambient("Ambient Lighting", Range(0, 1)) = 0.7
		_AmbientColor("Ambient Color", Color) = (1,1,1,1)
	}

		SubShader
		{
			Tags {"Queue" = "Transparent" "RenderType" = "Transparent" }
			//Tags {"RenderType" = "Opaque" }
			LOD 100
			//Transparent
			//ZWrite On
			ZWrite Off
			//AlphaTest GEqual [_CutoutThresh]
			//Blend SrcAlpha OneMinusSrcAlpha
			Cull Off


			Pass
			{
				CGPROGRAM
				#pragma vertex vert
				#pragma fragment frag

				#include "UnityCG.cginc"
				//#include "Lighting.cginc"
				#include "HairCommon.cginc"

				sampler2D _MainTex;
				sampler2D _AlphaTex;
				sampler2D _AmbientOcclusion;
				sampler2D _Brightness;

				sampler2D _SpecularShift;
				// For offset and scaling; just here as an example.
				float4 _MainTex_ST;
				float4 _TintColor;
				float4 _Highlight1;
				float4 _Highlight2;
				float _PrimaryShift;
				float _SecondaryShift;
				sampler2D _SecondarySparkle;
				float _CutoutThresh;
				float _AlphaMultiplier;

				float _SpecExp1;
				float _SpecExp2;

				float _Ambient;
				float4 _AmbientColor;

				// camera depth texture; built-in
				sampler2D _CameraDepthTexture;
				// generated by MeshSorter script
				sampler2D _DeepOpacityMap;
				// generated by ShadowMapTest
				sampler2D _ShadowMap;
				float _ShadowCascades;
				// generated by TestScreenPosRunner
				//float4x4 _DepthView;
				//float4x4 _DepthProjection;
				float4x4 _DepthVP;

				// https://en.wikibooks.org/wiki/Cg_Programming/Unity/Light_Attenuation
				uniform float4x4 unity_WorldToLight; // transformation 
				  // from world to light space (from Autolight.cginc)

				v2f vert(vertexInput v)
				{
					v2f o;
					o.pos = UnityObjectToClipPos(v.pos);
					o.posModelSpace = v.pos;
					o.uv = TRANSFORM_TEX(v.uv, _MainTex);
					// @TODO: Why do these methods (UnityObjectToViewPos vs mul(UNITY_MATRIX_MV, vector) )
					// produce different results?

					//https://forum.unity.com/threads/transform-direction-from-world-space-to-view-space.413620/
					//o.tangentWorldSpace = normalize(mul((float3x3)UNITY_MATRIX_MV, v.tangent));// normalize(mul(unity_ObjectToWorld, float4(v.tangent.xyz, 0))); //normalize(UnityObjectToViewPos(v.tangent));
					o.tangentWorldSpace = normalize(mul( float4(v.tangent.xyz, 0), UNITY_MATRIX_IT_MV));// normalize(mul(unity_ObjectToWorld, float4(v.tangent.xyz, 0))); //normalize(UnityObjectToViewPos(v.tangent));					
					//o.tangentWorldSpace = normalize(mul(UNITY_MATRIX_IT_MV, float4(v.tangent.xyz, 0)));// normalize(mul(unity_ObjectToWorld, float4(v.tangent.xyz, 0))); //normalize(UnityObjectToViewPos(v.tangent));					
					//o.normalWorldSpace = normalize(mul((float3x3)UNITY_MATRIX_MV, v.normal));// normalize(mul(unity_ObjectToWorld, float4(v.normal, 0))); //normalize(UnityObjectToViewPos(v.normal));
					o.normalWorldSpace = normalize(mul(float4(v.normal.xyz, 0), UNITY_MATRIX_IT_MV));// normalize(mul(unity_ObjectToWorld, float4(v.tangent.xyz, 0))); //normalize(UnityObjectToViewPos(v.tangent));					
					//o.normalWorldSpace = normalize(mul(UNITY_MATRIX_IT_MV, float4(v.normal.xyz, 0)));// normalize(mul(unity_ObjectToWorld, float4(v.tangent.xyz, 0))); //normalize(UnityObjectToViewPos(v.tangent));					
					// We want to ignore the w otherwise normalization will fail horribly
					//o.tangentWorldSpace = normalize(mul(UNITY_MATRIX_MV, float4(v.tangent.xyz, 0) ) );// UnityObjectToViewPos(v.tangent));
					//o.normalWorldSpace = normalize(mul(UNITY_MATRIX_MV, float4(v.normal, 0) ) );//normalize(UnityObjectToViewPos(v.normal));
					o.biTangentWorldSpace = normalize(cross(o.normalWorldSpace, o.tangentWorldSpace)) * v.tangent.w;

					// https://docs.unity3d.com/Manual/SL-DepthTextures.html


					// http://williamchyr.com/2013/11/unity-shaders-depth-and-normal-textures/
					o.scrPos = ComputeScreenPos(o.pos);

					return o;
				}


				fixed4 frag(v2f i) : SV_Target
				{
					fixed4 col;
				
					// Get light direction in world space.
					// @TODO: add support for point lights (needs different approach)
					float3 lightDirection = normalize(_WorldSpaceLightPos0.xyz);
					lightDirection = normalize(mul((float3x3)UNITY_MATRIX_V, lightDirection));
					// Get view direction in world space.
					float3 viewDirection = normalize(WorldSpaceViewDir(i.posModelSpace) );
					viewDirection = normalize(mul((float3x3)UNITY_MATRIX_V, viewDirection));

					/*normalize(_WorldSpaceCameraPos
						- mul(unity_ObjectToWorld, i.posModelSpace).xyz);
					viewDirection = normalize(mul(UNITY_MATRIX_MV, viewDirection));*/


					//float specExp1 = 64;
					//float specExp2 = 48;

					col.rgb = HairLighting(i.biTangentWorldSpace, i.normalWorldSpace, lightDirection, viewDirection,
						i.uv, tex2D(_AmbientOcclusion, i.uv).r,
						tex2D(_SpecularShift, i.uv).r - 0.5, _PrimaryShift, _SecondaryShift, tex2D(_MainTex, i.uv).rgb, _TintColor,
						_Highlight1, _SpecExp1, _Highlight2, _SpecExp2, tex2D(_SecondarySparkle, i.uv).r, _LightColor0,
						_Ambient * _AmbientColor
						);
					
					//float depthValue = Linear01Depth(tex2Dproj(_CameraDepthTexture, UNITY_PROJ_COORD(i.scrPos)).r);
					//float depthValue = Linear01Depth(tex2Dproj(_DeepOpacityMap, UNITY_PROJ_COORD(i.scrPos)).r);
					//float depthValue = (tex2Dproj(_DeepOpacityMap, UNITY_PROJ_COORD(i.scrPos)).r);

					// http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/#rendering-the-shadow-map
					//float4 shadowCoord = mul(_DepthProjection, mul(_DepthView, mul(unity_ObjectToWorld, float4(i.posModelSpace.xyz, 1.0)).xyz));
					float4 shadowWorld = mul(unity_ObjectToWorld, float4(i.posModelSpace.xyz, 1.0));
					float4 shadowCoord = mul(_DepthVP, shadowWorld);

					// "Computes texture coordinate for doing a screenspace-mapped texture sample. Input is clip space position."
					shadowCoord = ComputeScreenPos(shadowCoord);
					// from https://forum.unity.com/threads/how-do-i-render-my-own-shadow-map.471293/
					//float lightDepth = 1.0 - tex2Dproj(_ShadowTex, IN.shadowCoords).r;

					//float lightDepth = tex2D(_ShadowMap, shadowCoord).r;
					float lightDepth = tex2D(_DeepOpacityMap, shadowCoord).r;
					//float lightDepth = tex2Dproj(_DeepOpacityMap, UNITY_PROJ_COORD(shadowCoord)).r;
					//float lightDepth = tex2Dproj(_DeepOpacityMap, UNITY_PROJ_COORD(i.scrPos)).r;

					//float depthValue = (tex2Dproj(_ShadowMap, UNITY_PROJ_COORD(i.scrPos)).r);
					float depthValue = lightDepth;

					// discard fragment if white (or very close)
					if (1 - depthValue < 0.1) {
						//discard;
					}

					col.r = depthValue;
					col.g = depthValue;
					col.b = depthValue;

					col.a = tex2D(_AlphaTex, i.uv).r * _AlphaMultiplier;

					// Alpha cutoff.
					//if (col.a >= _CutoutThresh) {
					//	col.a = 1;// _Transparency;
					//}
					// This could be put in an else statement, but wouldn't improve performance.
					//clip(col.a - _CutoutThresh);
					//clip(col.a < _CutoutThresh ? -1 : 1);
					if (col.a < _CutoutThresh) {
						discard;
					}
					return col;
				}

			ENDCG
			}
		}
}